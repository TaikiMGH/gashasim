# 崩壊スターレイル 確率計算器

本アプリケーションは、ゲーム「崩壊スターレイル」のガチャ（跳躍）において、指定した枚数の限定キャラクターや光円錐を、**現在の所持リソース（星玉、チケット）で獲得できる確率**と、**目標達成までのガチャ回数分布およびそれに必要な星玉**をシミュレートするWebアプリケーションです。

**デプロイ先URL:** https://gashasim.onrender.com/

## ローカルでの実行方法

1.  **リポジトリをクローンします。**
    ```bash
    git clone https://github.com/TaikiMGH/gashasim.git
    cd gashasim
    ```

2.  **必要なライブラリをインストールします。**
    ```bash
    pip install -r requirements.txt
    ```

3.  **Flaskアプリケーションを実行します。**
    ```bash
    flask run
    ```

4.  ブラウザで `http://127.0.0.1:5000` にアクセスします。

---

## 仕様書

以下は、本アプリケーションの仕様詳細です。

## 1. 概要

本アプリケーションは、ゲーム「崩壊スターレイル」のガチャ（跳躍）において、指定した枚数の限定キャラクターや光円錐を、**現在の所持リソース（星玉、チケット）で獲得できる確率**と、**目標達成までのガチャ回数分布およびそれに必要な星玉**をシミュレートするWebアプリケーションである。

## 2. シミュレーターの目的

ユーザーが入力した情報に基づき、以下の項目を算出・表示する。

-   **目標達成確率:** 入力したガチャ状況（所持リソース、現在の天井状況）で、目標枚数を達成できる確率は何％かを表示する。
-   **目標達成までのガチャ回数分布:** **リソースの制限を考慮せず、目標枚数を達成できる確率が、`25%`, `50%`, `75%`, `99%` となる特定のガチャ回数と、その回数までに消費する星玉の総数、および星芒により獲得するチケット枚数を表示する。**

---

## 3. 入力項目

ユーザーはシミュレーションの前提条件として、以下の情報を入力する。

-   **目標枚数:**
    -   目当ての限定☆5キャラクター: `n`枚
    -   目当ての限定☆5光円錐: `m`本
    -   **シミュレーション対象のガチャは、`n`と`m`の値に基づいて自動的に決定されます。**
        -   `n > 0` かつ `m == 0` の場合: `限定キャラクター跳躍` をシミュレーションします。
        -   `n == 0` かつ `m > 0` の場合: `限定光円錐跳躍` をシミュレーションします。
        -   `n > 0` かつ `m > 0` の場合: `限定キャラクター跳躍` と `限定光円錐跳躍` の両方をシミュレーション対象とします。
        -   `n == 0` かつ `m == 0` の場合: シミュレーションは実行されません。
-   **現在のガチャ状況:**
    -   **所持している星玉の数:** ガチャの原資となるゲーム内通貨。
    -   **所持しているガチャチケットの枚数:**
    -   **前回☆5を入手してからのガチャ回数:** 天井計算に使用する。
    -   **次回の☆5がピックアップ確定か:** (Yes/No)
-   **シミュレーション回数:** 結果の精度を調整するための試行回数。デフォルトは100回。

---

## 4. 計算ロジック

本シミュレーターでは、複雑な確率変動（天井、ピックアップ確定、星芒によるチケット交換）を正確に考慮するため、**モンテカルロシミュレーション** を採用する。シミュレーションは、以下の2つの目的のために独立して実行される。

1.  **現在のリソースでの目標達成確率の計算:**
    -   ユーザーの初期所持リソース（星玉、チケット）を消費しながらガチャを回し、星芒によるチケット交換もリアルタイムで考慮する。
    -   リソースが尽きるか、目標を達成するまでシミュレーションを続ける。
    -   目標を達成できたシミュレーションの割合を「目標達成確率」として算出する。
2.  **目標達成までのガチャ回数分布の計算:**
    -   リソースの制限を考慮せず、目標達成までガチャを回し続ける。
    -   目標達成までに要した総ガチャ回数、その過程で獲得した星芒チケット数、および星玉を消費した総額を記録する。
    -   記録されたデータから、各パーセンタイル（25%, 50%, 75%, 99%）におけるガチャ回数、消費星玉、獲得星芒チケット数を算出する。

### 4.1. ガチャの基本仕様

#### 4.1.1. 排出確率

| ガチャの種類 | ☆5 | ☆4 | ☆3 |
| :--- | :--- | :--- | :--- |
| **限定キャラクター** | 0.6% | 5.1% (キャラ: 2.55%, 光円錐: 2.55%) | 94.3% |
| **限定光円錐** | 0.8% | 6.6% (キャラ: 3.3%, 光円錐: 3.3%) | 92.6% |

#### 4.1.2. 天井（pity）システム

-   **☆5確定:**
    -   **キャラクター跳躍:** 90回目の跳躍で☆5が確定。
        -   キャラクターのガチャは74連目から1連毎に6%ずつ確率UPします。例：73連→0.6％,74連→6.6％,80連→42.6％
    -   **光円錐跳躍:** 80回目の跳躍で☆5が確定。
        光円錐のガチャは64連目から6％ずつ上がる
    -   ☆5を引いた時点でカウントはリセットされる。
-   **☆4確定:**
    -   10回目の跳躍で☆4以上が確定。
    -   ☆4以上を引いた時点でカウントはリセットされる。

#### 4.1.3. ピックアップ仕様

-   **限定キャラクター:**
    -   ☆5当選時、**50%** の確率でピックアップキャラが出現。
    -   外れた場合、次回の☆5は **100%** ピックアップキャラとなる。
    -   このガチャから☆5光円錐は排出されない。
-   **限定光円錐:**
    -   ☆5当選時、**75%** の確率でピックアップ光円錐が出現。
    -   外れた場合、次回の☆5は **100%** ピックアップ光円錐となる。
    -   このガチャから☆5キャラクターは排出されない。

### 4.2. ガチャ資源の循環（消えない星芒）

ガチャの過程で入手できる「消えない星芒」をガチャチケットに交換するサイクルを考慮する。「星芒」`20`個でガチャチケット`1`枚と交換可能。

| 入手条件 | 獲得個数 |
| :--- | :--- |
| ☆5ピックアップキャラ（2～7回目） | 40個 |
| ピックアップ外の☆5キャラ（1～7回目） | 40個 |
| ☆5キャラ（8回目以降） | 100個 |
| ☆4キャラ | 20個 |
| ☆5光円錐 | 40個 |
| ☆4光円錐 | 8個 |

---

## 5. 画面設計（UI/UX）

-   **UX優先:** ユーザーが迅速に結果を把握できるよう、操作の簡潔さと結果表示の分かりやすさを最優先とする。
-   **入力エリア:** 上記「3. 入力項目」をユーザーが直感的に設定できるフォームを配置する。
-   **実行ボタン:** 「計算する」などのボタンを配置する。
-   **結果表示エリア:** 上記「2. シミュレーターの目的」で定義した**目標達成確率**と**目標達成までのガチャ回数分布**を、視覚的に（グラフなどを用いて）かつ要点を絞って分かりやすく表示する。
    -   「現在のリソースで目標を達成できる確率: XX.XX%」と表示する。
    -   目標達成できたシミュレーションがある場合、その下に「(星芒によりチケット平均XX枚相当を**追加で**獲得)」と表示する。
    -   「目標達成までのガチャ回数分布と消費星玉」として、各パーセンタイル（25%, 50%, 75%, 99%）について「XX%の確率で達成: YY回 (星玉ZZ個を消費, 星芒によりチケットAA枚相当獲得)」と表示する。

## 6. 開発要件

-   **フロントエンド:** HTML, CSS, JavaScript
-   **バックエンド:** Python (Flask)
-   **ライブラリ:** Flask-Cors, numpy

## 7. 開発ステップ案

1.  **UIの骨格作成:** HTML/CSSで入力フォームと結果表示エリアのレイアウトを構築する。
2.  **コアロジック実装:** Pythonで、単一のガチャ試行（確率計算、天井、ピックアップ判定）を行う関数を実装する。
3.  **シミュレーション実装:** 上記ロジックを複数回実行し、**現在のリソースで目標を達成できる確率**と**目標達成までのガチャ回数分布**をモンテカルロ法などで計算する機能を実装する。「星芒」の循環も考慮に入れる。
4.  **APIの構築:** フロントエンドからの入力値を受け取り、シミュレーション結果を返すAPIエンドポイントを作成する。
5.  **フロントエンド連携:** ユーザーの入力値をAPIに送信し、返された結果を画面に描画する処理を実装する。
6.  **テストと検証:** 既知の条件下での期待値と比較するなどして、計算ロジックの正確性を検証・調整する。